<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<a href="../index.html">â¬†ï¸  Up</a><br><hr>
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
	  <link rel="stylesheet" href="../../style.css" />

	
	<title>NSA: POPCOUNT</title>
</head>
<body>

<p>Source: <a href="https://vaibhavsagar.com/blog/2019/09/08/popcount">https://vaibhavsagar.com/blog/2019/09/08/popcount</a></p>

<hr>

<h1>POPCOUNT and the NSA</h1>

<hr>


<p><strong><code>popcount</code></strong> is a CPU instruction whose <strong>only purpose</strong> is
<strong>to count how many bits are set to <code>1</code> inside a binary word (8 bits = 1 byte)</strong>.</p>

<code>popcount(00100110) == 3   // because there are three â€œ1â€ bits
popcount(01100000) == 2   // because there are two â€œ1â€ bits</code>

<p>Each bit that is set to <code>1</code> is added to the total.
(<a href="https://vaibhavsagar.com/blog/2019/09/08/popcount/">vaibhavsagar.com</a>)</p>

<p>This <strong>is literally all it does</strong>: it counts 1s.
There is nothing magical hidden beyond that.
(<a href="https://tech-in-japan.github.io/articles/467083/">tech-in-japan.github.io</a>)</p>

<hr>

<h2>ğŸ’» Why does this instruction exist?</h2>

<h3>ğŸ§® Real-world uses of <code>popcount</code></h3>

<ol>
    <li>
        <strong>Cryptography and data analysis</strong><br>
        Determining how many bits are active in encrypted or encoded data is part of analysis/attack algorithms.
    </li>
    <li>
        <strong>Error detection and correction</strong><br>
        The Hamming distance is calculated as:
        <code>popcount(x XOR y)</code>
    </li>
    <li>
        <strong>AI and binary neural networks</strong><br>
        Used for efficient inner products.
    </li>
    <li>
        <strong>Chess engines</strong><br>
        64-bit bitboards â†’ pure popcount.
    </li>
    <li>
        <strong>Data structures and compression</strong><br>
        Hashing, compression, and compact structures.
    </li>
</ol>

<hr>

<h2>âš™ï¸ How does it work internally?</h2>

<code class="language-c">int popcount(value) {
    int count = 0;
    for (i = 0; i < bits_in_word; i++) {
        if ((value >> i) & 1 == 1) count++;
    }
    return count;
}</code>

<p>In hardware it can run in <em>a single cycle</em>.
(<a href="https://www.felixcloutier.com/x86/popcnt">felixcloutier.com</a>)</p>

<hr>

<h2>ğŸ§¾ Real instruction (x86)</h2>

<ul>
    <li>takes a source value</li>
    <li>counts bits set to 1</li>
    <li>returns the number</li>
</ul>

<code>dest = number of bits â€œ1â€ in src</code>

<hr>

<h2>ğŸ¤” Is it always present?</h2>

<p>No. Older CPUs like the Intel Core 2 did not have it.
(<a href="https://softwareg.com.au/en-us/blogs/computer-hardware/cpu-does-not-have-popcnt">softwareg.com.au</a>)</p>

<hr>

<h2>ğŸ•µï¸â€â™‚ï¸ NSA and popcount</h2>

<p>The <strong>NSA</strong> pushed the development of hardware bit counting because
<strong>counting bits is key to cryptography and espionage</strong>.</p>

<h3>ğŸ” Cryptography = statistics</h3>

<blockquote>
ğŸ‘‰ Does this stream of bits actually look random?
</blockquote>

<p>This is where <code>popcount</code> comes in.</p>

<h3>ğŸ“Š Example</h3>

<code>popcount(data) / total_bits</code>

<p>If it doesnâ€™t give ~50/50 â†’ weak cipher.</p>

<h3>ğŸ’£ Hamming distance</h3>

<code>popcount(x XOR y)</code>

<p>If only a few bits change â†’ bad algorithm.</p>

<hr>

<h2>ğŸ§  Why hardware?</h2>

<ul>
    <li>millions of messages</li>
    <li>real time</li>
    <li>maximum speed</li>
</ul>

<p>Result: dedicated instructions â†’ now in your CPU.</p>

<hr>

<h2>ğŸ“œ Real history</h2>

<p><code>popcount</code> was not created for games.
It was created to <strong>break ciphers and spy</strong>.</p>

<hr>

<h2>ğŸ§  Final summary</h2>

<ul>
    <li><code>popcount</code> = counting bits</li>
    <li>counting bits = statistics</li>
    <li>statistics = cryptoanalysis</li>
    <li>cryptoanalysis = NSA</li>
</ul>

<p>Today you use it for AI or chess, but its origin is espionage.</p>

<hr>

<h1>Spanish</h1>

<h2>ğŸ§  Â¿QuÃ© es <em>popcount</em>?</h2>

<p><strong><code>popcount</code></strong> es una instrucciÃ³n de CPU cuyo <strong>Ãºnico propÃ³sito</strong> es
<strong>contar cuÃ¡ntos bits estÃ¡n en <code>1</code> dentro de una palabra binaria</strong>.</p>

<code>popcount(00100110) == 3   // porque hay tres bits "1"
popcount(01100000) == 2   // porque hay dos bits â€œ1â€</code>

<p>Cada bit que estÃ¡ en <code>1</code> se suma al total.
(<a href="https://vaibhavsagar.com/blog/2019/09/08/popcount/">vaibhavsagar.com</a>)</p>

<p>Eso <strong>es literalmente todo lo que hace</strong>: cuenta 1s.
Nada mÃ¡gico escondido mÃ¡s allÃ¡ de eso.
(<a href="https://tech-in-japan.github.io/articles/467083/">tech-in-japan.github.io</a>)</p>

<hr>

<h2>ğŸ’» Â¿Por quÃ© existe esta instrucciÃ³n?</h2>

<h3>ğŸ§® Usos reales de <code>popcount</code></h3>

<ol>
    <li>
        <strong>CriptografÃ­a y anÃ¡lisis de datos</strong><br>
        Determinar cuÃ¡ntos bits estÃ¡n activos en datos cifrados o codificados sirve como parte de algoritmos de anÃ¡lisis/ataque.
    </li>
    <li>
        <strong>Errores y correcciÃ³n de datos</strong><br>
        La distancia de Hamming se calcula como:
        <code>popcount(x XOR y)</code>
    </li>
    <li>
        <strong>IA y redes neuronales binarias</strong><br>
        Usado para productos internos eficientes.
    </li>
    <li>
        <strong>Motores de ajedrez</strong><br>
        Bitboards de 64 bits â†’ popcount puro.
    </li>
    <li>
        <strong>Estructuras de datos y compresiÃ³n</strong><br>
        Hashing, compresiÃ³n y estructuras compactas.
    </li>
</ol>

<hr>

<h2>âš™ï¸ Â¿CÃ³mo funciona internamente?</h2>

<code class="language-c">int popcount(value) {
    int count = 0;
    for (i = 0; i < bits_in_word; i++) {
        if ((value >> i) & 1 == 1) count++;
    }
    return count;
}</code>

<p>En hardware puede ejecutarse en <em>un solo ciclo</em>.
(<a href="https://www.felixcloutier.com/x86/popcnt">felixcloutier.com</a>)</p>

<hr>

<h2>ğŸ§¾ InstrucciÃ³n real (x86)</h2>

<ul>
    <li>toma un valor fuente</li>
    <li>cuenta bits en 1</li>
    <li>devuelve el nÃºmero</li>
</ul>

<code>dest = nÃºmero de bits â€œ1â€ de src</code>

<hr>

<h2>ğŸ¤” Â¿Siempre estÃ¡ presente?</h2>

<p>No. CPUs viejos como Intel Core 2 no la tenÃ­an.
(<a href="https://softwareg.com.au/en-us/blogs/computer-hardware/cpu-does-not-have-popcnt">softwareg.com.au</a>)</p>

<hr>

<h2>ğŸ•µï¸â€â™‚ï¸ NSA y popcount</h2>

<p>La <strong>NSA</strong> empujÃ³ el desarrollo de hardware para contar bits porque
<strong>contar bits es clave en cripto y espionaje</strong>.</p>

<h3>ğŸ” CriptografÃ­a = estadÃ­stica</h3>

<blockquote>
ğŸ‘‰ Â¿Este flujo de bits parece realmente aleatorio?
</blockquote>

<p>AhÃ­ entra <code>popcount</code>.</p>

<h3>ğŸ“Š Ejemplo</h3>

<code>popcount(datos) / total_bits</code>

<p>Si no da ~50/50 â†’ cifrado dÃ©bil.</p>

<h3>ğŸ’£ Distancia de Hamming</h3>

<code>popcount(x XOR y)</code>

<p>Si pocos bits cambian â†’ algoritmo malo.</p>

<hr>

<h2>ğŸ§  Â¿Por quÃ© en hardware?</h2>

<ul>
    <li>millones de mensajes</li>
    <li>tiempo real</li>
    <li>mÃ¡xima velocidad</li>
</ul>

<p>Resultado: instrucciones dedicadas â†’ hoy en tu CPU.</p>

<hr>

<h2>ğŸ“œ Historia real</h2>

<p><code>popcount</code> no naciÃ³ para juegos.
NaciÃ³ para <strong>romper cifrados y espiar</strong>.</p>

<hr>

<h2>ğŸ§  Resumen final</h2>

<ul>
    <li><code>popcount</code> = contar bits</li>
    <li>contar bits = estadÃ­stica</li>
    <li>estadÃ­stica = criptoanÃ¡lisis</li>
    <li>criptoanÃ¡lisis = NSA</li>
</ul>

<p>Hoy lo usÃ¡s para IA o ajedrez, pero el origen es espionaje.</p>


</body>
</html>
